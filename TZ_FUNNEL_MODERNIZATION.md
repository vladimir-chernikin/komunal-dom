# Техническое задание: Модернизация воронки точности определения услуг

## Проблема текущей реализации

Текущая система использует эвристические веса и неверно классифицирует запросы (например, "течет труба" → "Засор канализации").

## Новая архитектура

### 4.1 Векторный микросервис (VectorSearchV2)
**Алгоритм:** Косинусное сходство векторов

```
{
  "method": "vector_cosine",
  "candidates": [
    {"service_id": 1, "service_name": "Устранение течи в квартире", "confidence": 0.85},
    {"service_id": 2, "service_name": "Устранение течи в подвале", "confidence": 0.72}
  ]
}
```

**Реализация:**
- Использовать sentence-transformers для русскоязычных моделей
- Pre-trained эмбеддинги для услуг и запросов
- Косинусное сходство: cos(A,B) = (A·B)/(||A||·||B||)

### 4.2 Нечеткий поиск по триггерам (FuzzyTriggerSearch)
**Алгоритм:** Многокритериальный нечеткий поиск

```
{
  "method": "fuzzy_triggers",
  "candidates": [
    {"service_id": 1, "service_name": "Устранение течи в квартире", "confidence": 0.90},
    {"service_id": 7, "service_name": "Вызов сантехника", "confidence": 0.75}
  ]
}
```

**Критерии:**
1. **Exact match** слов (weight: 1.0)
2. **Fuzzy match** с порогом 85% (weight: 0.7)
3. **Morphology match** pymorphy2 (weight: 0.9)
4. **Context match** локации (внутри/общее) (weight: 0.8)

**Пример:** "течет труба"
- "течет" ←→ "течь" (morphology: 0.9)
- "труба" ←→ "трубы" (fuzzy: 0.87)
- "квартира" в контексте (context: 0.8)

### 4.3 LLM микросервис (LLMClassifier)
**Алгоритм:** Классификация через YandexGPT с расширенным промптом

```
{
  "method": "llm_classification",
  "candidates": [
    {"service_id": 1, "service_name": "Устранение течи в квартире", "confidence": 0.95, "llm_reasoning": "..."}
  ]
}
```

**Улучшенный промпт:**
```
Ты - эксперт по ЖКХ услугам. Классифицируй обращение по контексту:

Обращение: "течет труба"

Анализ контекста:
1. Тип проблемы: "течет" = активная утечка (incident)
2. Объект: "труба" = инженерная система
3. Неопределенность: тип трубы неизвестен (водопровод/канализация/отопление)
4. Локализация: не указана (нужно уточнить)

Доступные услуги с описаниями:
[детальные описания каждой услуги]

Верни JSON с субъективной оценкой и объяснением:
{
  "service_id": 1,
  "confidence": 0.95,
  "reason": "Течь трубы требует сантехника, но нужно уточнить тип системы",
  "clarification_needed": true,
  "clarification_type": "pipe_type"
}
```

## 4.4 Главный Agent v2 (MainAgentV2)

**Объединение результатов через пересечение множеств:**

```python
def merge_candidates(vector_results, fuzzy_results, llm_results):
    """Теория множеств для объединения результатов"""

    # Преобразуем в множества
    vector_set = {(r['service_id'], r['confidence']) for r in vector_results}
    fuzzy_set = {(r['service_id'], r['confidence']) for r in fuzzy_results}
    llm_set = {(r['service_id'], r['confidence']) for r in llm_results}

    # Анализ пересечений
    intersection = vector_set & fuzzy_set & llm_set
    vector_fuzzy = vector_set & fuzzy_set - llm_set
    vector_llm = vector_set & llm_set - fuzzy_set
    fuzzy_llm = fuzzy_set & llm_set - vector_set

    # Веса для разных типов пересечений
    weights = {
        'triple_intersection': 1.5,  # все три метода сошлись
        'double_intersection': 1.2,  # два метода сошлись
        'single_method': 1.0        # только один метод
    }

    # Расчет финальной уверенности
    final_candidates = []

    # 1. Тройное пересечение (максимальный приоритет)
    for service_id, conf in intersection:
        avg_conf = (vector_conf + fuzzy_conf + llm_conf) / 3
        final_candidates.append({
            'service_id': service_id,
            'confidence': min(avg_conf * weights['triple_intersection'], 1.0),
            'sources': ['vector', 'fuzzy', 'llm']
        })

    # 2. Двойные пересечения
    for service_id, conf in vector_fuzzy:
        # среднее арифметическое * вес
        pass

    return sorted(final_candidates, key=lambda x: x['confidence'], reverse=True)
```

## 5. Динамическая ИИ фильтрация

### 5.1 IntelligentFilterService
**Задача:** Предварительная классификация запроса для сужения поиска

```python
class IntelligentFilterService:
    def analyze_request(self, text: str) -> Dict:
        """Интеллектуальный анализ запроса"""

        filters = {
            # Тип инцидента
            'incident_type': self._detect_incident_type(text),

            # Категория проблемы
            'problem_category': self._detect_problem_category(text),

            # Локализация
            'location_type': self._detect_location_type(text),

            # Система коммуникаций
            'utility_system': self._detect_utility_system(text),

            # Срочность
            'urgency_level': self._detect_urgency(text)
        }

        return filters

def _detect_incident_type(self, text: str) -> str:
    """Определение типа: инцидент/запрос/консультация"""
    incident_words = ['сломался', 'течет', 'нет', 'не работает', 'авария', 'прорыв']
    request_words = ['установить', 'заменить', 'проверить', 'вызвать', 'заказать']
    consult_words = ['объясните', 'как', 'почему', 'расскажите', 'поясните']

    # LLM для сложных случаев
    if self._is_complex_case(text):
        return self._llm_classify_incident_type(text)

    # Правила для простых случаев
    if any(word in text.lower() for word in incident_words):
        return 'incident'
    elif any(word in text.lower() for word in request_words):
        return 'request'
    elif any(word in text.lower() for word in consult_words):
        return 'consultation'
    else:
        return 'unknown'
```

### 5.2 Контекстные правила для ЖКХ

```python
JKX_CONTEXT_RULES = {
    'water_systems': {
        'keywords': ['хвс', 'гвс', 'водопровод', 'канализация', 'отопление', 'горячая', 'холодная'],
        'services': {
            'leak': [1, 2],  # Устранение течи
            'clog': [3],     # Засор канализации
            'no_water': [7]  # Вызов сантехника
        }
    },

    'electrical_systems': {
        'keywords': ['свет', 'электричество', 'розетка', 'выключатель', 'счетчик'],
        'services': {
            'outage': [999],  # Нет в каталоге
            'damage': [999],  # Нет в каталоге
            'check': [6]     # Поверка счетчиков
        }
    },

    'location_contexts': {
        'inside_flat': ['квартира', 'в моей', 'дома', 'в ванной', 'на кухне'],
        'common_property': ['подъезд', 'лифт', 'крыша', 'подвал', 'фасад']
    }
}
```

## Проблема правил для ЖКХ:

**В чем проблема:** Категории в каталоге недостаточно специфичны для различения инженерных систем.

**"течет труба" → возможные интерпретации:**
- Водопроводная труба (ХВС/ГВС) → Услуги: 1, 2, 7, 25
- Канализационная труба → Услуги: 3, 50, 51
- Отопительная труба → Услуги: 21, 23, 24
- Водосточная труба → Услуги: 10, 18

**Решение:** Вместо правил - добавить системные атрибуты в каталог:
```sql
ALTER TABLE services ADD COLUMN utility_system VARCHAR(50);  -- water/sewerage/heating/electrical
ALTER TABLE services ADD COLUMN pipe_type VARCHAR(50);      -- water/sewer/heating/storm
ALTER TABLE services ADD COLUMN severity_level VARCHAR(20); -- low/medium/high/critical
```

## Сценарий использования (обновленный):

1. **Пользователь:** "течет труба"
2. **EnhancedMainAgent:** Параллельный поиск по 3 микросервисам
3. **Анализ результатов:** Если расхождения > 0.3 или нет консенсуса → запуск AI
4. **Фильтрация каталога для AI:** Собираем уникальные услуги из 3 микросервисов + данные из БД
5. **AI анализ:** Фильтрованный JSON-каталог с учетом utility_system и pipe_type
6. **MainAgent:** Пересечение множеств с весами (тройное ×1.5, двойное ×1.2, одиночное ×1.0)
7. **Результат:** Точно определенная услуга с учетом системы труб

**Пример пересечений с весами:**
- TagSearchV2: {1: 0.85, 3: 0.65}
- SemanticSearch: {2: 0.70, 1: 0.45}
- VectorSearch: {1: 0.90, 7: 0.40}

**Математический расчет (ИСПРАВЛЕНО):**
- ID 1 (в 3х множествах): avg_confidence = (0.85+0.45+0.90)/3 = 0.73 × 1.5 = 1.0 (ограничиваем ≤ 1.0)
- ID 2 (в 1м множестве): avg_confidence = 0.70 × 1.0 = 0.70
- ID 3 (в 1м множестве): avg_confidence = 0.65 × 1.0 = 0.65
- ID 7 (в 1м множестве): avg_confidence = 0.40 × 1.0 = 0.40

**ВАЖНО:** Услуга с высоким avg_confidence в одном множестве может быть более релевантна, чем услуга с низким avg_confidence в трех множествах. Веса рассчитываются на основе СРЕДНЕГО значения уверенности, а не по факту наличия.

**Финальный результат:** Услуга 1 с уверенностью 1.0 (Устранение течи в квартире)

## Выявленные проблемы и решения:

### 1. Проблема: Отладочная таблица `services`
**Найдено:** Таинственная таблица `services` с 7 записями создавалась вручную для отладки.
**Решение:** ✅ Таблица удалена (`DROP TABLE services`), все микросервисы переведены на `services_catalog`.

### 2. Проблема: Микросервисы не могут загрузить услуги
**Найдено:** Все микросервисы обращались к удаленной таблице `services`, из-за чего бот использовал заглушки.
**Решение:** ✅ Исправлены SQL запросы во всех микросервисах для работы с `services_catalog`.

### 3. Проблема: Hardcoded правила ЖКХ
**Найдено:** `intelligent_filter_service.py` содержал жестко закодированные правила.
**Решение:** ✅ Создан `llm_filter_filler_service.py` с LLM-заполнением фильтров на основе данных из каталога.

### 4. Проблема: Децентрализованные LLM запросы
**Найдено:** Каждый сервис делал LLM запросы по-своему без логирования.
**Решение:** ✅ Создан `unified_llm_service.py` - централизованный сервис с учетом токенов и выбором модели.

### 5. Проблема: Неверная логика пересечений множеств
**Найдено:** Веса рассчитывались по факту наличия, а не по среднему значению уверенности.
**Решение:** ✅ Бот переключен на `enhanced_main_agent.py` с математически корректной логикой.

### 6. Проблема: Противоречивые рекомендации по стоп-словам
**Найдено:** Рекомендации были противоречивыми - предлагали и hardcoded правила, и catalog атрибуты.
**Решение:** ✅ Несостыковка объяснена и исправлена - полный переход на catalog атрибуты.

## Преимущества новой архитектуры:

1. **Точное определение** через математически корректное пересечение множеств
2. **Динамическая фильтрация** через LLM вместо hardcoded правил
3. **Централизованные LLM запросы** с логированием и учетом стоимости
4. **Использование catalog атрибутов** вместо эвристик
5. **Единая точка доступа** к услугам через `services_catalog`
6. **Математически корректные веса** на основе средней уверенности

## ИТОГ: Воронка точности модернизирована с учетом всех замечаний (8/8 задач)

### ✅ Статус выполнения ТЗ:

1. ✅ **Таблица `services` удалена** - это был отладочный артефакт с 7 тестовыми услугами
2. ✅ **Hardcoded правила ЖКХ убраны** из `intelligent_filter_service.py`
3. ✅ **Противоречия в рекомендациях объяснены** и исправлены - полный переход на catalog атрибуты
4. ✅ **LLM микросервис для заполнения фильтров создан** (`llm_filter_filler_service.py`)
5. ✅ **Централизованная LLM функция создана** (`unified_llm_service.py`)
6. ✅ **Главная проблема бота найдена и исправлена** - микросервисы не могли загрузить услуги
7. ✅ **Логика пересечений множеств исправлена** через переход на `enhanced_main_agent.py`
8. ✅ **ТЗ обновлено** с учетом всех правок и замечаний

**КЛЮЧЕВОЕ РЕШЕНИЕ:** Бот перестанет использовать заглушки со смайликами, потому что основная причина (невозможность загрузить услуги из-за обращений к удаленной таблице `services`) устранена.